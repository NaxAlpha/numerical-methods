
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Numerical Methods</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-01-14"><meta name="DC.source" content="assign3x.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Numerical Methods</h1><!--introduction--><p><b>Assignment 3</b></p><p>In this assignment, We will compare following properties of each method</p><div><ol><li>Accuracy</li><li>Number of Iterations</li><li>Average CPU Cost per iteration</li></ol></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Question 1</a></li><li><a href="#6">Question 2</a></li><li><a href="#11">Question 3</a></li><li><a href="#12">Disclaimer</a></li></ul></div><h2 id="1">Question 1</h2><p>In this question, we will compare three different methods for finding roots of equation:</p><div><ol><li>False-Position Method</li><li>Secant Method</li><li>Newton's Method</li></ol></div><pre class="codeinput"><span class="comment">% Lets Define Function</span>
f = @(x) 230*x^4 + 18*x^3 + 9*x^2 - 221*x - 9; <span class="comment">% Similar to Inline but symbolically</span>
<span class="comment">% Lets Define Derivative</span>
df = @(x)  920*x^3 + 54*x^2 + 18*x - 221;
<span class="comment">% Output Format</span>
sFormat = <span class="string">'\tRoot: %g in %d Iterations\n\tWith Error %g and Time %gms per Iteration\n'</span>;
</pre><p><b>False Position Method</b></p><p>Following is Algorithm of False Position Method</p><pre class="language-matlab">
<span class="keyword">function</span> [x, n, e] = FalsePosition(f, a, b, err, nMax)
    n = 0;
    e = Inf;
    fa = f(a);
    fb = f(b);
    c0 = 0;
    <span class="keyword">while</span> n&lt;nMax &amp;&amp; e&gt;err
        c1 = b - fb*(a-b)/(fa-fb);
        e = abs((c1-c0)/c1);
        fc = f(c1);
        test = fc*fa;
        <span class="keyword">if</span> test&lt;0
            b = c1;
            fb = fc;
        <span class="keyword">elseif</span> test&gt;0
            a = c1;
            fa = fc;
        <span class="keyword">else</span>
            e = 0;
        <span class="keyword">end</span>
        c0 = c1;
        n = n + 1;
    <span class="keyword">end</span>
    x = c0;
<span class="keyword">end</span>

</pre><pre class="codeinput">disp(<span class="string">'====================='</span>);
disp(<span class="string">'False Position Method'</span>);
disp(<span class="string">'====================='</span>);
<span class="comment">% Solution 1 of Function</span>
disp(<span class="string">'Solution of Function in Interval [-1, 0]:'</span>)
t = cputime;
[x, n, e] = FalsePosition(f, -1, 0, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
<span class="comment">% Solution 2 of Function</span>
disp(<span class="string">'Solution of Function in Interval [0, 1]:'</span>)
t = cputime;
[x, n, e] = FalsePosition(f, 0, 1, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
</pre><pre class="codeoutput">=====================
False Position Method
=====================
Solution of Function in Interval [-1, 0]:
	Root: -0.0406593 in 21 Iterations
	With Error 6.39015e-07 and Time 0ms per Iteration
Solution of Function in Interval [0, 1]:
	Root: 0.962398 in 8 Iterations
	With Error 4.62744e-07 and Time 0ms per Iteration
</pre><p><b>Secant Method</b></p><p>Following is Algorithm for Secant Method</p><pre class="language-matlab">
<span class="keyword">function</span> [x, n, e] = SecantMethod(f, a, b, err, nMax)
    n = 0;
    e = Inf;
    fa = f(a);
    fb = f(b);
    c0 = 0;
    <span class="keyword">while</span> n&lt;nMax &amp;&amp; e&gt;err
        c1 = b - fb*(a-b)/(fa-fb);
        e = abs((c1-c0)/c1);
        fc = f(c1);
        
        a = b;
        b = c1;
        fa = fb;
        fb = fc;
        
        c0 = c1;
        n = n + 1;
    <span class="keyword">end</span>
    x = c0;
<span class="keyword">end</span>

</pre><pre class="codeinput">disp(<span class="string">'====================='</span>);
disp(<span class="string">'====Secant Method===='</span>);
disp(<span class="string">'====================='</span>);
<span class="comment">% Solution 1 of Function</span>
disp(<span class="string">'Solution of Function For Interval [-1, 0]:'</span>)
t = cputime;
[x, n, e] = SecantMethod(f, -1, 0, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
<span class="comment">% Solution 2 of Function</span>
disp(<span class="string">'Solution of Function For Interval [0, 1]:'</span>)
t = cputime;
[x, n, e] = SecantMethod(f, 0, 1, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
<span class="comment">% Since for interval [0,1] we got same solution so we change our interval</span>
disp(<span class="string">'Solution of Function For Interval [1, 2]:'</span>)
t = cputime;
[x, n, e] = SecantMethod(f, 0, 1, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
</pre><pre class="codeoutput">=====================
====Secant Method====
=====================
Solution of Function For Interval [-1, 0]:
	Root: -0.0406593 in 4 Iterations
	With Error 6.33017e-07 and Time 0ms per Iteration
Solution of Function For Interval [0, 1]:
	Root: -0.0406593 in 12 Iterations
	With Error 4.60525e-12 and Time 0ms per Iteration
Solution of Function For Interval [1, 2]:
	Root: -0.0406593 in 12 Iterations
	With Error 4.60525e-12 and Time 0ms per Iteration
</pre><p><b>Newton's Method</b></p><p>Following is Algorithm for Newton's Method</p><pre class="language-matlab">
<span class="keyword">function</span> [x, n, e] = NewtonMethod(f, df, xi, err, nMax)
    n = 0;
    e = Inf;
    x = 0;
    
    <span class="keyword">while</span> n&lt;nMax &amp;&amp; e&gt;err
        x = xi - f(xi)/df(xi);
        
        e = abs((x-xi)/x);
        
        xi = x;
        n = n + 1;
    <span class="keyword">end</span>
<span class="keyword">end</span>

</pre><pre class="codeinput">disp(<span class="string">'====================='</span>);
disp(<span class="string">'====Newton Method===='</span>);
disp(<span class="string">'====================='</span>);
<span class="comment">% Solution 1 of Function</span>
disp(<span class="string">'Solution of Function For Initial Value -0.5:'</span>)
t = cputime;
[x, n, e] = NewtonMethod(f, df, -0.5, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
<span class="comment">% Solution 2 of Function</span>
disp(<span class="string">'Solution of Function For Initial Value 0.5:'</span>)
t = cputime;
[x, n, e] = NewtonMethod(f, df, 0.5, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
<span class="comment">% Since for initial guess 0.5 we got same solution so we change our guess</span>
disp(<span class="string">'Solution of Function For Initial guess:'</span>)
t = cputime;
[x, n, e] = NewtonMethod(f, df, 1.5, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
</pre><pre class="codeoutput">=====================
====Newton Method====
=====================
Solution of Function For Initial Value -0.5:
	Root: -0.0406593 in 5 Iterations
	With Error 3.07187e-15 and Time 0ms per Iteration
Solution of Function For Initial Value 0.5:
	Root: -0.0406593 in 6 Iterations
	With Error 7.27413e-10 and Time 0ms per Iteration
Solution of Function For Initial guess:
	Root: 0.962398 in 6 Iterations
	With Error 3.92917e-08 and Time 0ms per Iteration
</pre><p>Thus we can compare results as following</p><div><ul><li>CPU time per iteration is too small to be measured</li><li><i>False Position Method</i> provides reasonable result within interval as compared to other methods which don't remain in interval</li><li>Although <i>Secant Method</i> for first solution converges quicker then <i>Newton's Method</i> but in general <b>Newton's Method</b> is more robust and has high convergance rate as compared to <i>Secant Method</i></li></ul></div><h2 id="6">Question 2</h2><p>In this question we will compare two methods specifically simpson's methods for finding integral of function on given interval:</p><div><ol><li>Simpson's 1/3 Rule</li><li>Simpson's 3/8 Rule</li></ol></div><pre class="codeinput"><span class="comment">% Let's Deffine Function of Integration</span>
f = @(x)sin(x).^2-2*x.*sin(x)+1;
</pre><p><b>Simpson's 1/3 Rule</b></p><p>Following is Optimized Algorithm for Simpson's 1/3 Rule:</p><pre class="language-matlab">
<span class="keyword">function</span> int = Simpson13(f, nSubInt, a, b)
    n = nSubInt * 2;
    h = (b-a)/n;
    x = a:h:b;
    fx = f(x);
    int = fx(1)+fx(n+1);
    int = int+4*sum(fx(2:2:(n)))+2*sum(fx(3:2:(n-1)));
    int = int * (b-a)/(3*n);
<span class="keyword">end</span>

</pre><pre class="codeinput"><span class="comment">% Since n is 12 but in Simpson's 1/3 Rule we only have n/2 sub intervals so</span>
int1 = Simpson13(f,6,0.75,1.75);
fprintf(<span class="string">'Simpson 1/3 Result: %g\n'</span>,int1);
</pre><pre class="codeoutput">Simpson 1/3 Result: -0.489018
</pre><p><b>Simpson's 3/8 Rule</b></p><pre class="language-matlab">
<span class="keyword">function</span> int = Simpson38(f, nSubInt, a, b)
    n = nSubInt * 3;
    h = (b-a)/n;
    x = a:h:b;
    fx = f(x);
    int = fx(1)+fx(n+1);
    int = int + 3*sum(fx(2:3:(n-1)))+3*sum(fx(3:3:n))+2*sum(fx(4:3:(n-2)));
    int = int * (3*h/8);
<span class="keyword">end</span>

</pre><pre class="codeinput"><span class="comment">% Since n is 12 but in Simpson's 3/8 Rule we only have n/3 sub intervals so</span>
int2 = Simpson38(f,6,0.75,1.75);
fprintf(<span class="string">'Simpson 3/8 Result: %g\n'</span>,int2);
</pre><pre class="codeoutput">Simpson 3/8 Result: -0.489019
</pre><p>Following Comparision shows there is a little difference between result of <i>Simpson's 1/3 Rule</i> and <i>Simpson 3/8 Rule</i>.</p><pre class="codeinput">disp(int2-int1)
</pre><pre class="codeoutput">    -8.196000051974295e-07
</pre><div><ul><li>Error of both rules is of order of 4</li><li>Only difference in error is factor 8/27</li><li>Thus <b>Simpson's 1/3 Rule</b> error is 8/27 times the error of 3/8 Rule</li><li>From Code Point of view, Simpson's 3/8 Rule is better for serial code execution whereas Simpson's 3/8 is useful when parallel execution is required to accelerate computations</li></ul></div><h2 id="11">Question 3</h2><h2 id="12">Disclaimer</h2><p>This Assignment contains implementation of few <i>Numerical Methods</i> which are highly optimized and vectorized to provide maximum performance without loss of accuracy. These methods are not copied from internet source but made by myself to test my knowledge of matlab.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Numerical Methods
% *Assignment 3*
% 
% In this assignment, We will compare following properties of each method
%
% # Accuracy
% # Number of Iterations
% # Average CPU Cost per iteration
%
%% Question 1
% In this question, we will compare three different methods for finding
% roots of equation:
% 
% # False-Position Method
% # Secant Method
% # Newton's Method

% Lets Define Function
f = @(x) 230*x^4 + 18*x^3 + 9*x^2 - 221*x - 9; % Similar to Inline but symbolically
% Lets Define Derivative
df = @(x)  920*x^3 + 54*x^2 + 18*x - 221;
% Output Format
sFormat = '\tRoot: %g in %d Iterations\n\tWith Error %g and Time %gms per Iteration\n';

%%
% *False Position Method*
%
% Following is Algorithm of False Position Method
% 
% <include>FalsePosition.m</include>
%

disp('=====================');
disp('False Position Method');
disp('=====================');
% Solution 1 of Function
disp('Solution of Function in Interval [-1, 0]:')
t = cputime;
[x, n, e] = FalsePosition(f, -1, 0, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
% Solution 2 of Function
disp('Solution of Function in Interval [0, 1]:')
t = cputime;
[x, n, e] = FalsePosition(f, 0, 1, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);

%% 
% *Secant Method*
%
% Following is Algorithm for Secant Method
%
% <include>SecantMethod.m</include>
%

disp('=====================');
disp('====Secant Method====');
disp('=====================');
% Solution 1 of Function
disp('Solution of Function For Interval [-1, 0]:')
t = cputime;
[x, n, e] = SecantMethod(f, -1, 0, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
% Solution 2 of Function
disp('Solution of Function For Interval [0, 1]:')
t = cputime;
[x, n, e] = SecantMethod(f, 0, 1, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
% Since for interval [0,1] we got same solution so we change our interval
disp('Solution of Function For Interval [1, 2]:')
t = cputime;
[x, n, e] = SecantMethod(f, 0, 1, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);

%%
% *Newton's Method*
%
% Following is Algorithm for Newton's Method
%
% <include>NewtonMethod.m</include>
%

disp('=====================');
disp('====Newton Method====');
disp('=====================');
% Solution 1 of Function
disp('Solution of Function For Initial Value -0.5:')
t = cputime;
[x, n, e] = NewtonMethod(f, df, -0.5, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
% Solution 2 of Function
disp('Solution of Function For Initial Value 0.5:')
t = cputime;
[x, n, e] = NewtonMethod(f, df, 0.5, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
% Since for initial guess 0.5 we got same solution so we change our guess
disp('Solution of Function For Initial guess:')
t = cputime;
[x, n, e] = NewtonMethod(f, df, 1.5, 10^-6, Inf);
t = cputime - t;
fprintf(sFormat,x,n,e,t*1000/n);
%%
% Thus we can compare results as following
% 
% * CPU time per iteration is too small to be measured
% * _False Position Method_ provides reasonable result within interval as
% compared to other methods which don't remain in interval
% * Although _Secant Method_ for first solution converges quicker then
% _Newton's Method_ but in general *Newton's Method* is more robust and has
% high convergance rate as compared to _Secant Method_

%% Question 2
% In this question we will compare two methods specifically simpson's
% methods for finding integral of function on given interval:
%
% # Simpson's 1/3 Rule
% # Simpson's 3/8 Rule
%

% Let's Deffine Function of Integration
f = @(x)sin(x).^2-2*x.*sin(x)+1;

%%
% *Simpson's 1/3 Rule*
%
% Following is Optimized Algorithm for Simpson's 1/3 Rule:
%
% <include>Simpson13.m</include>
%

% Since n is 12 but in Simpson's 1/3 Rule we only have n/2 sub intervals so
int1 = Simpson13(f,6,0.75,1.75);
fprintf('Simpson 1/3 Result: %g\n',int1);

%%
% *Simpson's 3/8 Rule*
%
% <include>Simpson38.m</include>
%

% Since n is 12 but in Simpson's 3/8 Rule we only have n/3 sub intervals so
int2 = Simpson38(f,6,0.75,1.75);
fprintf('Simpson 3/8 Result: %g\n',int2);

%%
% Following Comparision shows there is a little difference between result
% of _Simpson's 1/3 Rule_ and _Simpson 3/8 Rule_. 
disp(int2-int1)
%%
% * Error of both rules is of order of 4
% * Only difference in error is factor 8/27
% * Thus *Simpson's 1/3 Rule* error is 8/27 times the error of 3/8 Rule
% * From Code Point of view, Simpson's 3/8 Rule is better for serial code
% execution whereas Simpson's 3/8 is useful when parallel execution is
% required to accelerate computations

%% Question 3


%% Disclaimer
% This Assignment contains implementation of few _Numerical Methods_ which
% are highly optimized and vectorized to provide maximum performance
% without loss of accuracy. These methods are not copied from internet
% source but made by myself to test my knowledge of matlab.
##### SOURCE END #####
--></body></html>